/~ NOTICE This parser is based directly upon the token / grammar specification for GLSL ES 1.0.17 
 ~ by the Khronos Group available at http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf
 ~/

/~ ~~~~~~~ Token Defns ~~~~~~~~ ~/

/~ whitespace ~/
!	' |\t\n'
;

/~ keywords ~/
'attribute'	ATTRIBUTE
'const'		CONST
'bool'		BOOL
'float' 	FLOAT
'int'		INT
'break'		BREAK
'continue'	CONTINUE
'do'		DO
'else'		ELSE
'for'		FOR
'if'		IF
'discard'	DISCARD
'return'	RETURN
'bvec2'		BVEC2
'bvec3'		BVEC3
'bvec4'		BVEC4
'ivec2'		IVEC2
'ivec3'		IVEC3
'ivec4'		IVEC4
'vec2'		VEC2
'vec3'		VEC3
'vec4'		VEC4
'mat2'		MAT2
'mat3'		MAT3
'mat4'		MAT4
'in'		IN
'out'		OUT
'inout'		INOUT
'uniform'	UNIFORM
'varying'	VARYING
'sampler2d'	SAMPLER2D
'samplercube'	SAMPLERCUBE
'struct'	STRUCT
'void'		VOID
'while'		WHILE
;


/~ identifiers of the form 
 ~ identifier : nondigit | identifier nondigit | identifier digit
 ~/
'[a-zA-Z\_]+[0-9]*'									IDENTIFIER
'void|bool|int|float|(bi)?vec[2-4]|mat[2-4]|sampler2D|samplerCube'			TYPE_NAME
/~ float constants (conveniently the same format as accepted by parseFloat)
 ~ floating-constant : fractional-constant [exponent-part] | digit-sequence exponent-part 
 ~ fractional-constant : digit-sequence . digit-sequence | digit-sequence . | . digit-sequence
 ~ exponent-part : e [sign] digit-sequence | E [sign] digit-sequence
 ~/
'([0-9]+\.[0-9]+|[0-9]+\.|\.[0-9]+)((e|E)(\+|\-)?[0-9]+)?|[0-9]+(e|E)(\+|\-)?[0-9]+'	FLOATCONSTANT	[* %match = parseFloat(%match); *]
/~ integer constants (same as parseInt)
 ~ integer-constant : decimal-constant | octal-constant | hexadecimal-constant
 ~ decimal-constant :  nonzero-digit | decimal-constant digit
 ~ octal-constant : 0 | octal-constant octal-digit
 ~ hexadecimal-constant : 0x hexadecimal-digit | 0X hexadecimal-digit | hexadecimal-constant hexadecimal-digit
 ~/
'[1-9][0-9]+|0[0-7]+|0(x|X)[0-9a-fA-F]+'						INTCONSTANT	[* %match = parseInt(%match); *]
'true|false'	     	BOOLCONSTANT	[* %match = %match == 'true' *]
/~ FIELD_SELECTION TODO ~/
'<<' LEFT_OP
'>>' RIGHT_OP
'\+\+' INC_OP
'--' DEC_OP
'<=' LE_OP
'>=' GE_OP
'==' EQ_OP
'!=' NE_OP
'&&' AND_OP
'\|\|' OR_OP
/~ '^^' XOR_OP TODO: is this valid? ~/
'\*=' MUL_ASSIGN
'/=' DIV_ASSIGN
'\+=' ADD_ASSIGN
'%=' MOD_ASSIGN
/~reserved
LEFT_ASSIGN
RIGHT_ASSIGN
AND_ASSIGN
XOR_ASSIGN
OR_ASSIGN~/
'=' SUB_ASSIGN
;

'\(' LEFT_PAREN 
'\)' RIGHT_PAREN 
'\[' LEFT_BRACKET 
'\]' RIGHT_BRACKET 
'{' LEFT_BRACE 
'}' RIGHT_BRACE 
'.' DOT
',' COMMA 
':' COLON 
'=' EQUAL 
';' SEMICOLON 
'!' BANG 
'-' DASH 
'~' TILDE 
'\+' PLUS 
'\*' STAR 
'/' SLASH 
'%' PERCENT
'<' LEFT_ANGLE 
'>' RIGHT_ANGLE 
'\|' VERTICAL_BAR 
'^' CARET 
'&' AMPERSAND 
'\?' QUESTION
'invariant' INVARIANT
;

'highp' HIGH_PRECISION 
'mediump' MEDIUM_PRECISION 
'lowp' LOW_PRECISION 
'precision' PRECISION
;

##

/~ ~~~~~~~~~ Grammar ~~~~~~~~~ ~/

program:
	translation_unit
	;

variable_identifier:
        IDENTIFIER
	;

primary_expression:
	variable_identifier 
        | INTCONSTANT 
        | FLOATCONSTANT 
        | BOOLCONSTANT 
        | LEFT_PAREN expression RIGHT_PAREN
	;

postfix_expression:
        primary_expression 
        | postfix_expression LEFT_BRACKET integer_expression RIGHT_BRACKET 
        | function_call 
        /~ | postfix_expression DOT FIELD_SELECTION TODO ~/
        | postfix_expression INC_OP 
        | postfix_expression DEC_OP
	;
 
integer_expression:
        expression
	;
 
function_call:
        function_call_generic
	;
 
function_call_generic:
        function_call_header_with_parameters RIGHT_PAREN 
        | function_call_header_no_parameters RIGHT_PAREN
	;

function_call_header_no_parameters:
        function_call_header VOID 
        | function_call_header
	;
 
function_call_header_with_parameters:
        function_call_header assignment_expression 
        | function_call_header_with_parameters COMMA assignment_expression 
	;

function_call_header:
        function_identifier LEFT_PAREN 
	;

function_identifier:
        constructor_identifier 
        | IDENTIFIER
	;

constructor_identifier:
        FLOAT 
        | INT 
        | BOOL 
        | VEC2 
        | VEC3 
        | VEC4 
        | BVEC2
        | BVEC3
        | BVEC4
        | IVEC2
        | IVEC3
        | IVEC4
        | MAT2
        | MAT3
        | MAT4
	| TYPE_NAME
	;

unary_expression:
        postfix_expression 
        | INC_OP unary_expression 
        | DEC_OP unary_expression 
        | unary_operator unary_expression 
	;

unary_operator:
        PLUS 
        | DASH 
        | BANG 
        | TILDE
	;

multiplicative_expression:
        unary_expression 
        | multiplicative_expression STAR unary_expression
        | multiplicative_expression SLASH unary_expression
        | multiplicative_expression PERCENT unary_expression
	;

additive_expression:
        multiplicative_expression 
        | additive_expression PLUS multiplicative_expression 
        | additive_expression DASH multiplicative_expression
	;
 
shift_expression:
        additive_expression 
        | shift_expression LEFT_OP additive_expression
        | shift_expression RIGHT_OP additive_expression
	;

relational_expression:
        shift_expression 
        | relational_expression LEFT_ANGLE shift_expression 
        | relational_expression RIGHT_ANGLE shift_expression 
        | relational_expression LE_OP shift_expression 
        | relational_expression GE_OP shift_expression
	;
 
equality_expression:
        relational_expression 
        | equality_expression EQ_OP relational_expression 
        | equality_expression NE_OP relational_expression
	;

and_expression:
        equality_expression 
        | and_expression AMPERSAND equality_expression
	;

exclusive_or_expression:
        and_expression 
        | exclusive_or_expression CARET and_expression
	;

inclusive_or_expression:
        exclusive_or_expression 
        | inclusive_or_expression VERTICAL_BAR exclusive_or_expression
	;

logical_and_expression:
        inclusive_or_expression 
        | logical_and_expression AND_OP inclusive_or_expression
	;

/~ No operator defined!
logical_xor_expression:
        logical_and_expression 
        | logical_xor_expression XOR_OP logical_and_expression 
	;
~/

logical_or_expression:
        /~ logical_xor_expression Not used ~/
	logical_and_expression
        | logical_or_expression OR_OP logical_and_expression 
	;

conditional_expression:
        logical_or_expression 
        | logical_or_expression QUESTION expression COLON assignment_expression 
	;

assignment_expression:
        conditional_expression 
        | unary_expression assignment_operator assignment_expression 
	;

assignment_operator:
        EQUAL 
        | MUL_ASSIGN
        | DIV_ASSIGN
        | MOD_ASSIGN
        | ADD_ASSIGN 
        | SUB_ASSIGN 
/~      | LEFT_ASSIGN  Reserved
        | RIGHT_ASSIGN
        | AND_ASSIGN  
        | XOR_ASSIGN  
        | OR_ASSIGN ~/
	;

expression:
        assignment_expression 
        | expression COMMA assignment_expression 
	;

constant_expression:
        conditional_expression
	;

declaration:
        function_prototype SEMICOLON 
        | init_declarator_list SEMICOLON 
        | PRECISION precision_qualifier type_specifier_no_prec SEMICOLON
	;

function_prototype:
        function_declarator RIGHT_PAREN 
	;

function_declarator:
        function_header 
        | function_header_with_parameters 
	;

function_header_with_parameters:
        function_header parameter_declaration 
        | function_header_with_parameters COMMA parameter_declaration 
	;

function_header:
        fully_specified_type IDENTIFIER LEFT_PAREN 
	;

parameter_declarator:
        type_specifier IDENTIFIER 
        | type_specifier IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET 
	;

parameter_declaration:
        type_qualifier parameter_qualifier parameter_declarator 
        | parameter_qualifier parameter_declarator 
        | type_qualifier parameter_qualifier parameter_type_specifier 
        | parameter_qualifier parameter_type_specifier 
	;

parameter_qualifier:
        /~ TODO also empty ~/
        IN 
        | OUT 
        | INOUT
	;

parameter_type_specifier:
        type_specifier 
        | type_specifier LEFT_BRACKET constant_expression RIGHT_BRACKET
	;

init_declarator_list:
        single_declaration 
        | init_declarator_list COMMA IDENTIFIER 
        | init_declarator_list COMMA IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET
        | init_declarator_list COMMA IDENTIFIER EQUAL initializer 
	;

single_declaration:
        fully_specified_type 
        | fully_specified_type IDENTIFIER 
        | fully_specified_type IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET 
        | fully_specified_type IDENTIFIER EQUAL initializer 
        | INVARIANT IDENTIFIER   /~ TODO Vertex only. ~/
	;

fully_specified_type:
        type_specifier 
        | type_qualifier type_specifier
	; 

type_qualifier:
        CONST 
        | ATTRIBUTE   /~ TODO Vertex only. ~/
        | VARYING 
        | INVARIANT VARYING
        | UNIFORM 
	;

type_specifier:
        type_specifier_no_prec
        | precision_qualifier type_specifier_no_prec
	;

type_specifier_no_prec:
        VOID 
        | FLOAT 
        | INT 
        | BOOL 
        | VEC2 
        | VEC3 
        | VEC4 
        | BVEC2 
        | BVEC3 
        | BVEC4 
        | IVEC2 
        | IVEC3 
        | IVEC4 
        | MAT2
        | MAT3
        | MAT4
        | SAMPLER2D
        | SAMPLERCUBE
        | struct_specifier
        | TYPE_NAME
	;
 
precision_qualifier:
        HIGH_PRECISION
        | MEDIUM_PRECISION
        | LOW_PRECISION
	;

struct_specifier:
        STRUCT IDENTIFIER LEFT_BRACE struct_declaration_list RIGHT_BRACE 
        | STRUCT LEFT_BRACE struct_declaration_list RIGHT_BRACE 
	;

struct_declaration_list:
        struct_declaration 
        | struct_declaration_list struct_declaration 
	;

struct_declaration:
        type_specifier struct_declarator_list SEMICOLON
	;

struct_declarator_list:
        struct_declarator 
        | struct_declarator_list COMMA struct_declarator
	;
 
struct_declarator:
        IDENTIFIER 
        | IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET
	;
 
initializer:
        assignment_expression 
	;

declaration_statement:
        declaration 
	;

statement_no_new_scope:
        compound_statement_with_scope
        | simple_statement
	;
 
simple_statement:
        declaration_statement 
        | expression_statement 
        | selection_statement 
        | iteration_statement 
        | jump_statement
	;
 
compound_statement_with_scope:
        LEFT_BRACE RIGHT_BRACE 
        | LEFT_BRACE statement_list RIGHT_BRACE
	;
 
statement_with_scope:
        compound_statement_no_new_scope 
        | simple_statement
	;
 
compound_statement_no_new_scope:
        LEFT_BRACE RIGHT_BRACE 
        | LEFT_BRACE statement_list RIGHT_BRACE
	;
 
statement_list:
        statement_no_new_scope
        | statement_list statement_no_new_scope
	;

expression_statement:
        SEMICOLON 
        expression SEMICOLON
	;

selection_statement:
        IF LEFT_PAREN expression RIGHT_PAREN selection_rest_statement 
	;

selection_rest_statement:
        statement_with_scope ELSE statement_with_scope 
        | statement_with_scope
	;

condition:
        expression 
        | fully_specified_type IDENTIFIER EQUAL initializer 
	;

iteration_statement:
        WHILE LEFT_PAREN condition RIGHT_PAREN statement_no_new_scope 
        | DO statement_with_scope WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON 
        | FOR LEFT_PAREN for_init_statement for_rest_statement RIGHT_PAREN statement_no_new_scope 
	;

for_init_statement:
        expression_statement 
        | declaration_statement 
	;

conditionopt:
        condition 
        /~ TODO empty ~/
	;

for_rest_statement:
        conditionopt SEMICOLON 
        | conditionopt SEMICOLON expression 
	;

jump_statement:
        CONTINUE SEMICOLON 
        | BREAK SEMICOLON 
        | RETURN SEMICOLON 
        | RETURN expression SEMICOLON 
        | DISCARD SEMICOLON   /~ TODO Fragment shader only. ~/
	;

translation_unit:
        external_declaration 
        | translation_unit external_declaration
	;

external_declaration:
        function_definition 
        | declaration;

function_definition:
        function_prototype compound_statement_no_new_scope
	;

[*
print("Starting...");
var error_offsets = new Array();
var error_lookaheads = new Array();
var error_count = 0;
//We're getting the expression via command line parameter
var str = new String( arguments[0] );
/*
The "##PREFIX##" is a wild card, where an optional, unique name will be inserted by
JS/CC when the parser is constructed. This enables the possibility to use multiple
different parsers in one project or script.
*/
if( ( error_count = __##PREFIX##parse( str,
error_offsets, error_lookaheads ) ) > 0 )
{
for( i = 0; i < error_count; i++ )
print( "Parse error near \""
+ str.substr( error_offsets[i] ) +
"\", expecting \"" +
error_lookaheads[i].join() +
"\"" );
}
print("Finishing...")
*]